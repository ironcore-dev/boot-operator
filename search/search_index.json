{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Boot-Operator Documentation","text":""},{"location":"#overview","title":"Overview","text":"<p>Boot Operator is a Kubernetes-based project designed to automate the deployment of tools required for booting bare metal servers. It integrates web servers and Kubernetes controllers to manage the entire process of provisioning, booting, and configuring the server.</p>"},{"location":"#problem-it-solves","title":"Problem It Solves","text":"<p>When a bare metal server boots with a network boot method (e.g., PXE or HTTP boot), it typically contacts a DHCP or proxy DHCP server to obtain the necessary information for booting. The DHCP server then provides the IP address of a TFTP server (for PXE) or a web server (for HTTP boot), along with additional boot parameters.</p> <p>Traditionally, managing these network boot servers requires manual configuration. Boot Operator automates this by incorporating the boot servers into Kubernetes deployments. By leveraging Kubernetes controllers, each machine's boot process is handled declaratively, making it simpler to manage and scale.</p>"},{"location":"#key-components","title":"Key Components","text":"<p>Boot Operator includes the following key components:</p> <ul> <li> <p>IPXE Boot Server </p> <ul> <li>Handles <code>/ipxe</code> requests  </li> <li>Responds with an iPXE script, which the bare metal server uses to download the necessary OS components  </li> <li>This endpoint is typically called directly by the server during boot and is commonly used in PXE boot scenarios</li> </ul> </li> <li> <p>HTTP Boot Server </p> <ul> <li>Handles <code>/httpboot</code> requests  </li> <li>Returns a JSON response containing the location of the UKI (Unified Kernel Image) that the server should download  </li> <li>The DHCP server extension typically handles the response and sends the UKI image location to the server  </li> <li>Common in modern cloud-native bare metal setups, especially for containers and minimal OS images</li> </ul> </li> <li> <p>Image Proxy Server </p> <ul> <li>Handles <code>/image</code> requests</li> <li>Extracts layers from public OCI (Open Container Initiative) images, with current support for GHCR (GitHub Container Registry) only </li> <li>Downloads specific layers based on the requested URI and image specifications  </li> <li>Example:</li> <li><code>wget http://SERVER_ADDRESS:30007/image?imageName=ghcr.io/ironcore-dev/os-images/gardenlinux&amp;version=1443.10&amp;layerName=application/vnd.ironcore.image.squashfs.v1alpha1.squashfs</code></li> </ul> </li> <li> <p>Ignition Server </p> <ul> <li>Handles <code>/ignition</code> requests  </li> <li>Responds with Ignition configuration content tailored to the client machine, identified by its UUID in the request URL.</li> </ul> </li> </ul> <p>These servers leverage Kubernetes controllers and API objects to manage the boot process and serve requests from bare metal machines. The architecture and specifics of the controllers and API objects are described in the architecture section of the documentation.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>Boot Operator mainly consists of the a set webservers and controllers working together to fulfill the requirement of the boot process of the Baremetal machines. </p>"},{"location":"architecture/#kubernetes-api","title":"Kubernetes API","text":"<p>Following are the Kubernetes CR and related controllers used to manage the boot infrastructure of the baremetal servers.</p> <ul> <li> <p>IPXEBootConfig </p> <ul> <li>The purpose of this CR and related controller is to allow users to configure the system to provide customised ipxe-script replies to the requests made by the baremetal servers.</li> <li>It allows users with references tailored ignition content, and customised ipxe-scripts to the related IPXEBootConfig object. </li> <li>There is usually a single IPXEBootConfig object corresponding to each of the baremetal servers. </li> </ul> </li> <li> <p>HTTPBootConfig</p> <ul> <li>The purpose of this CR and related controller is to allow users to configure the system to provide customised httpboot replies to the requests typically made by the DHCP servers. </li> <li>It allows users to reference the ignition content and customised ukiURL. </li> </ul> </li> </ul>"},{"location":"architecture/#architectural-diagrams","title":"Architectural Diagrams","text":""},{"location":"architecture/#workflow","title":"Workflow","text":"<p>Although the components of Boot Operator can function independently, this section describes a typical usecases of how they work together. </p> <ul> <li> <p>IPXE Workflow </p> <ul> <li>The IPXE workflow involves a DHCP server (e.g., FeDHCP) and the Boot Operator deployment with the necessary IPXE configuration flags.  </li> <li>When a bare metal server boots with the IPXE network option, it requests the <code>/ipxe</code> endpoint from the IPXE web server within the Boot Operator deployment via dhcp server. The server receives the IPXE script configured in the corresponding <code>IPXEBootConfig</code> object.  </li> <li>The server then fetches the Ignition content from the <code>/ignition</code> endpoint, as specified in the IPXE script and the configured Ignition content for the server.</li> </ul> </li> <li> <p>HTTPBoot Workflow </p> <ul> <li>The HTTPBoot workflow involves a specialized DHCP server (e.g., FeDHCP), the Boot Operator with HTTPBoot configuration enabled, and a UKI OS image hosted on a web server or registry.  </li> <li>When a bare metal server boots with the HTTPBoot option, it contacts the FeDHCP server, which returns the UKI image location from the external web server. FeDHCP internally uses the <code>/httpboot</code> endpoint exposed by the Boot Operator, fetching the required information from the related <code>HTTPBootConfig</code> object.  </li> <li>The server can then retrieve the Ignition content from the <code>/ignition</code> endpoint, as configured for the desired OS.</li> </ul> </li> </ul>"},{"location":"api-reference/api/","title":"API Reference","text":""},{"location":"api-reference/api/#packages","title":"Packages","text":"<ul> <li>boot.ironcore.dev/v1alpha1</li> </ul>"},{"location":"api-reference/api/#bootironcoredevv1alpha1","title":"boot.ironcore.dev/v1alpha1","text":"<p>Package v1alpha1 contains API Schema definitions for the settings.gardener.cloud API group</p> <p>Package v1alpha1 contains API Schema definitions for the boot v1alpha1 API group</p>"},{"location":"api-reference/api/#resource-types","title":"Resource Types","text":"<ul> <li>HTTPBootConfig</li> <li>IPXEBootConfig</li> </ul>"},{"location":"api-reference/api/#httpbootconfig","title":"HTTPBootConfig","text":"<p>HTTPBootConfig is the Schema for the httpbootconfigs API</p> Field Description Default Validation <code>apiVersion</code> string <code>boot.ironcore.dev/v1alpha1</code> <code>kind</code> string <code>HTTPBootConfig</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> HTTPBootConfigSpec <code>status</code> HTTPBootConfigStatus"},{"location":"api-reference/api/#httpbootconfigspec","title":"HTTPBootConfigSpec","text":"<p>HTTPBootConfigSpec defines the desired state of HTTPBootConfig</p> <p>Appears in: - HTTPBootConfig</p> Field Description Default Validation <code>systemUUID</code> string SystemUUID is the unique identifier (UUID) of the server. <code>ignitionSecretRef</code> LocalObjectReference IgnitionSecretRef is a reference to the secret containing Ignition configuration. <code>networkIdentifiers</code> string array NetworkIdentifiers is a list of IP addresses and MAC Addresses assigned to the server. <code>ukiURL</code> string UKIURL is the URL where the UKI (Unified Kernel Image) is hosted."},{"location":"api-reference/api/#httpbootconfigstate","title":"HTTPBootConfigState","text":"<p>Underlying type: string</p> <p>Appears in: - HTTPBootConfigStatus</p> Field Description <code>Ready</code> HTTPBootConfigStateReady indicates that the HTTPBootConfig has been successfully processed, and the next step (e.g., booting the server) can proceed. <code>Pending</code> HTTPBootConfigStatePending indicates that the HTTPBootConfig has not been processed yet. <code>Error</code> HTTPBootConfigStateError indicates that an error occurred while processing the HTTPBootConfig."},{"location":"api-reference/api/#httpbootconfigstatus","title":"HTTPBootConfigStatus","text":"<p>HTTPBootConfigStatus defines the observed state of HTTPBootConfig</p> <p>Appears in: - HTTPBootConfig</p> Field Description Default Validation <code>state</code> HTTPBootConfigState <code>conditions</code> Condition array Conditions represent the latest available observations of the IPXEBootConfig's state"},{"location":"api-reference/api/#ipxebootconfig","title":"IPXEBootConfig","text":"<p>IPXEBootConfig is the Schema for the ipxebootconfigs API</p> Field Description Default Validation <code>apiVersion</code> string <code>boot.ironcore.dev/v1alpha1</code> <code>kind</code> string <code>IPXEBootConfig</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> IPXEBootConfigSpec <code>status</code> IPXEBootConfigStatus"},{"location":"api-reference/api/#ipxebootconfigspec","title":"IPXEBootConfigSpec","text":"<p>IPXEBootConfigSpec defines the desired state of IPXEBootConfig</p> <p>Appears in: - IPXEBootConfig</p> Field Description Default Validation <code>systemUUID</code> string SystemUUID is the unique identifier (UUID) of the server. <code>systemIPs</code> string array SystemIPs is a list of IP addresses assigned to the server. <code>image</code> string Image is deprecated and will be removed. <code>kernelURL</code> string KernelURL is the URL where the kernel of the OS is hosted, eg. the URL to the Kernel layer of the OS OCI image. <code>initrdURL</code> string InitrdURL is the URL where the Initrd (initial RAM disk) of the OS is hosted, eg. the URL to the Initrd layer of the OS OCI image. <code>squashfsURL</code> string SquashfsURL is the URL where the Squashfs of the OS is hosted, eg.  the URL to the Squashfs layer of the OS OCI image. <code>ipxeServerURL</code> string IPXEServerURL is deprecated and will be removed. <code>ignitionSecretRef</code> LocalObjectReference IgnitionSecretRef is a reference to the secret containing the Ignition configuration. <code>ipxeScriptSecretRef</code> LocalObjectReference IPXEScriptSecretRef is a reference to the secret containing the custom IPXE script."},{"location":"api-reference/api/#ipxebootconfigstate","title":"IPXEBootConfigState","text":"<p>Underlying type: string</p> <p>Appears in: - IPXEBootConfigStatus</p> Field Description <code>Ready</code> IPXEBootConfigStateReady indicates that the IPXEBootConfig has been successfully processed, and the next step (e.g., booting the server) can proceed. <code>Pending</code> IPXEBootConfigStatePending indicates that the IPXEBootConfig has not been processed yet. <code>Error</code> IPXEBootConfigStateError indicates that an error occurred while processing the IPXEBootConfig."},{"location":"api-reference/api/#ipxebootconfigstatus","title":"IPXEBootConfigStatus","text":"<p>IPXEBootConfigStatus defines the observed state of IPXEBootConfig</p> <p>Appears in: - IPXEBootConfig</p> Field Description Default Validation <code>state</code> IPXEBootConfigState Important: Run \"make\" to regenerate code after modifying this file <code>conditions</code> Condition array Conditions represent the latest available observations of the IPXEBootConfig's state"},{"location":"development/create_uki/","title":"Create Sample UKI Image","text":""},{"location":"development/create_uki/#how-to-generate-a-uki-image-for-httpboot-with-gardenlinux","title":"How to Generate a UKI Image for HTTPBoot with Gardenlinux","text":""},{"location":"development/create_uki/#step-1-prerequisites","title":"Step 1: Prerequisites","text":"<ul> <li>Ensure you have the <code>ukify</code> tool installed on your system. This tool is essential for creating the UKI image.</li> <li>You will need administrative or root privileges to execute most of the commands described.</li> </ul>"},{"location":"development/create_uki/#step-2-download-and-prepare-gardenlinux-release","title":"Step 2: Download and Prepare Gardenlinux Release","text":"<ol> <li>Download the appropriate Gardenlinux release for your architecture. For example, a metal-based system with an AMD64 architecture, use the following command:    <pre><code>wget https://github.com/gardenlinux/gardenlinux/releases/download/1443.10/metal-gardener_prod_pxe-amd64-1443.10-8d098305.tar.xz\n</code></pre></li> <li>Extract the downloaded <code>.tar.xz</code> file:    <pre><code>tar -xvf metal-gardener_prod_pxe-amd64-1443.10-8d098305.tar.xz\n</code></pre></li> <li>Further extract the nested <code>*.pxe.tar.gz</code> which contains the kernel and initial RAM disk:    <pre><code>tar -xzf &lt;nested_tar_name&gt;.pxe.tar.gz\n</code></pre>    You should see files like <code>vmlinuz</code>, <code>initrd</code>, and <code>root.squashfs</code>.</li> </ol>"},{"location":"development/create_uki/#step-3-obtain-the-bootloader-stub","title":"Step 3: Obtain the Bootloader Stub","text":"<p>Download the EFI stub required for the UKI creation: <pre><code>tbd\n</code></pre></p>"},{"location":"development/create_uki/#step-4-create-the-uki-image","title":"Step 4: Create the UKI Image","text":"<p>Construct the UKI image using the <code>ukify</code> command. Ensure to replace placeholders with actual paths and URLs: <pre><code>ukify build --stub \"/path/to/stub\" --linux \"/path/to/vmlinuz\" --initrd \"/path/to/initrd\" --cmdline \"@cmdline\" --output \"/path/to/output/test.uki\"\n\n# Create file with the name cmdline, with following content\n# Use this as the sample command line, replace URLs and paths as necessary\ninitrd=/path/to/initrd gl.ovl=/:tmpfs gl.live=1 ip=dhcp console=ttyS0,115200 console=tty0 earlyprintk=ttyS0,115200 consoleblank=0 ignition.firstboot=1 ignition.config.url=IGNITION_URL ignition.platform.id=metal gl.url=SQUASHFS_URL\n</code></pre></p>"},{"location":"development/create_uki/#step-5-deploy-the-image-to-a-server","title":"Step 5: Deploy the Image to a Server","text":"<p>Copy the created <code>test.uki</code> to an Nginx server configured to serve the files: <pre><code>cp /path/to/output/test.uki /path/to/nginx/server/httpboot/test-uki.efi\n# Also, ensure the squashfs file is accessible via HTTP\ncp /path/to/root.squashfs /path/to/nginx/server/httpboot/squashfs\n</code></pre> Ensure EFI files are served by NGINX with the correct content-type. <pre><code> application/efi efi;\n</code></pre></p>"},{"location":"development/create_uki/#step-6-configure-httpboot","title":"Step 6: Configure HTTPBoot","text":"<p>Create a YAML configuration for the HTTPBoot client. Replace placeholders as required: <pre><code>apiVersion: boot.ironcore.dev/v1alpha1\nkind: HTTPBootConfig\nmetadata:\n  name: httpbootconfig-sample\n  namespace: boot-operator-system\nspec:\n  ignitionSecretRef:\n    name: ignition-http-sample\n    namespace: boot-operator-system\n  systemUUID: \"generate-this-uuid\"\n  systemIPs:\n    - \"1.1.1.1\"\n    - \"ip/mac-address-of-interfaces\"\n  ukiURL: \"http://[your-server-ip-or-domain]/httpboot/test-uki.efi\"\n</code></pre></p> <p>Apply this configuration to your cluster and ensure the metal machine is set to boot via HTTPBoot.</p>"},{"location":"development/dev_docs/","title":"boot-operator documentation","text":""},{"location":"development/dev_docs/#local-dev-setup","title":"Local dev setup","text":"<p>You can run the documentation via:</p> <pre><code>make startdocs\n</code></pre> <p>You can remove the <code>mkdocs</code> container image by running:</p> <pre><code>make cleandocs\n</code></pre>"},{"location":"usage/bootctl/","title":"bootctl","text":""},{"location":"usage/bootctl/#installation","title":"Installation","text":"<p>Install the <code>bootctl</code> CLI from source without cloning the repository. Requires Go to be installed.</p> <pre><code>go install https://github.com/ironcore-dev/boot-operator/cmd/bootctl@latest\n</code></pre>"},{"location":"usage/bootctl/#commands","title":"Commands","text":""},{"location":"usage/bootctl/#move","title":"move","text":"<p>The <code>bootctl move</code> command allows to move the boot Custom Resources which are <code>HTTPBootConfigs</code> and <code>IPXEBootConfigs</code> from one cluster to another.</p> <p>Warning!: Before running <code>bootctl move</code>, the user should take care of preparing the target cluster, including also installing all the required Custom Resources Definitions.</p> <p>You can use:</p> <p><pre><code>bootctl move --source-kubeconfig=\"path-to-source-kubeconfig.yaml\" --target-kubeconfig=\"path-to-target-kubeconfig.yaml\"\n</code></pre> to move the boot Custom Resources existing in all namespaces of the source cluster. In case you want to move the boot Custom Resources defined in a single namespace, you can use the <code>--namespace</code> flag.</p> <p>Secrets referred in the specification and ownership of a boot Custom Resource is also moved. If for a moved boot Custom Resource with an ownership there is no <code>ServerBootConfiguration</code> matching resource name on the target cluster, the owner won't be set and the move operation will succeed. To fail when such situation occurs set <code>--require-owners</code> to true. If a boot Custom Resource present on the source cluster exists on the target cluster with identical specification it and its secret won't be moved and no ownership of this object will be set on the target cluster. If the boot Custom Resource is absent on the target cluster but its secret is present, there will be no errors and the move operation will succeed. In case of any errors during the process there will be performed a cleanup and the target cluster will be restored to its previous state.</p> <p>Warning!:  <code>bootctl move</code> has been designed and developed around the bootstrap use case described below, and currently this is the only use case verified.</p> <p>If someone intends to use <code>bootctl move</code> outside of this scenario, it's recommended to set up a custom validation pipeline of it before using the command on a production environment.</p> <p>Also, it is important to notice that move has not been designed for being used as a backup/restore solution and it has several limitation for this scenario, like e.g. the implementation assumes the cluster must be stable while doing the move operation, and possible race conditions happening while the cluster is upgrading, scaling up, remediating etc. has never been investigated nor addressed.</p>"},{"location":"usage/bootctl/#pivot","title":"Pivot","text":"<p>Pivoting is a process for moving the Custom Resources and install Custom Resource Definitions from a source cluster to a target cluster.</p> <p>This can now be achieved with the following procedure:</p> <ol> <li>Use <code>make install</code> to install the boot Custom Resource Definitions into the target cluster</li> <li>Use <code>bootctl move</code> to move the boot Custom Resources from a source cluster to a target cluster</li> </ol>"},{"location":"usage/bootctl/#dry-run","title":"Dry run","text":"<p>With <code>--dry-run</code> option you can dry-run the move action by only printing logs without taking any actual actions. Use <code>--verbose</code> flag to enable verbose logging.</p>"},{"location":"usage/installation/","title":"Helm Installation Guide","text":"<p>This guide will help you install the Boot Operator using Helm.</p>"},{"location":"usage/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster (v1.16+)</li> <li>Helm (v3.0.0+)</li> </ul>"},{"location":"usage/installation/#steps","title":"Steps","text":"<ol> <li>Install the Chart</li> </ol> <p>Install the Boot Operator chart with the default values.</p> <pre><code>helm install boot-operator dist/chart\n</code></pre> <p>To customize the installation, you can override the default values using a <code>values.yaml</code> file or the <code>--set</code> flag.</p> <pre><code>helm install boot-operator dist/chart -f /path/to/your/values.yaml\n</code></pre> <ol> <li>Verify the Installation</li> </ol> <p>Check the status of the Helm release to ensure that the Boot Operator is installed successfully.</p> <pre><code>helm status boot-operator\n</code></pre> <p>You should see output indicating that the Boot Operator pods are running.</p>"},{"location":"usage/installation/#configuration","title":"Configuration","text":"<p>The <code>values.yaml</code> file allows you to configure various aspects of the Boot Operator. Below are some of the key configurations:</p>"},{"location":"usage/installation/#controller-manager","title":"Controller Manager","text":"Key Description Default Value <code>controllerManager.replicas</code> Number of replicas for the manager deployment <code>1</code> <code>controllerManager.manager.image.repository</code> Image repository for the manager container <code>registry/boot-operator</code> <code>controllerManager.manager.image.tag</code> Image tag for the manager container <code>\"v0.1.0\"</code> <code>controllerManager.manager.args</code> Arguments for the manager container <code>--ipxe-service-url=ipxe-service-url</code> <code>controllerManager.manager.resources</code> Resource requests and limits for the manager container <code>{cpu: 500m, memory: 128Mi}</code> (limits), <code>{cpu: 10m, memory: 64Mi}</code> (requests) <code>controllerManager.manager.livenessProbe</code> Liveness probe configuration for the manager container <code>{initialDelaySeconds: 15, periodSeconds: 20, httpGet: {path: /healthz, port: 8081}}</code> <code>controllerManager.manager.readinessProbe</code> Readiness probe configuration for the manager container <code>{initialDelaySeconds: 5, periodSeconds: 10, httpGet: {path: /readyz, port: 8081}}</code> <code>controllerManager.manager.containerSecurityContext</code> Security context for the manager container <code>{allowPrivilegeEscalation: false, capabilities: {drop: [\"ALL\"]}}</code> <code>controllerManager.podSecurityContext</code> Security context for the manager pod <code>{runAsNonRoot: true, seccompProfile: {type: RuntimeDefault}}</code> <code>controllerManager.terminationGracePeriodSeconds</code> Termination grace period for the manager pod <code>10</code> <code>controllerManager.serviceAccountName</code> Service account name for the manager pod <code>controller-manager</code> <code>controllerManager.tolerations</code> Tolerations for the manager pod <code>[{key: node-role.kubernetes.io/control-plane, effect: NoSchedule}]</code> <code>controllerManager.hostNetwork</code> Enable host networking for the manager pod <code>false</code> <code>controllerManager.strategy.type</code> Deployment strategy for the manager pod <code>Recreate</code> <ul> <li>rbac: Enable or disable RBAC.</li> <li>crd: Enable or disable CRDs.</li> <li>metrics: Enable or disable metrics export.</li> <li>webhook: Enable or disable webhooks.</li> <li>prometheus: Enable or disable Prometheus ServiceMonitor.</li> <li>certmanager: Enable or disable cert-manager injection.</li> <li>networkPolicy: Enable or disable NetworkPolicies.</li> </ul> <p>Refer to the <code>values.yaml</code> file for more details on each configuration option.</p>"},{"location":"usage/installation/#uninstallation","title":"Uninstallation","text":"<p>To uninstall the Boot Operator, run the following command:</p> <pre><code>helm uninstall boot-operator\n</code></pre> <p>This will remove all the resources associated with the Boot Operator.</p>"},{"location":"usage/installation/#additional-information","title":"Additional Information","text":"<p>For more detailed information, refer to the official documentation and Helm chart repository.</p>"}]}